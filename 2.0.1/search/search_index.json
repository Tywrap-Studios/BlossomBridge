{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to BlossomBridge","text":""},{"location":"#introduction","title":"Introduction","text":"<p>BlossomBridge is a small API for Tywrap Studios Mods, that adds a few minor things such as:</p> <ul> <li>A fletched Config system  utilizing Jankson  and some logic magic.</li> <li>A simple, yet niche Logging system , to maintain a consistent log format for all our mods.</li> <li>All written from the ground in Kotlin .</li> </ul>"},{"location":"#guides","title":"Guides","text":"<p>Depending on BlossomBridge  API Reference </p>"},{"location":"tags/","title":"Tags","text":"<p>On this page you can view all the tags for the pages of this documentation.</p>"},{"location":"tags/#tag:configuration-module","title":"Configuration Module","text":"<ul> <li>            Config Files          </li> <li>            Creating a ConfigClass          </li> <li>            Creating a LoggingHandler          </li> <li>            Ranges, Sets and Validation          </li> </ul>"},{"location":"tags/#tag:developer-guides","title":"Developer Guides","text":"<ul> <li>            Config Files          </li> <li>            Creating a ConfigClass          </li> <li>            Creating a LoggingHandler          </li> <li>            Getting Started          </li> <li>            Ranges, Sets and Validation          </li> <li>            Updating          </li> <li>            Using a LoggingHandler          </li> </ul>"},{"location":"tags/#tag:logging-module","title":"Logging Module","text":"<ul> <li>            Creating a LoggingHandler          </li> <li>            Using a LoggingHandler          </li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>In this part of the docs we will look at a basic setup using BlossomBridge!</p>"},{"location":"api/#prerequisites","title":"Prerequisites","text":"Jankson <p>Before we start, if you'd like to add Comments  to your Config file, you will have to install and include Jankson in your Gradle  project.</p> Groovy build.gradle<pre><code>dependencies {\n    ...\n\n    // blossombridge\n    implementation(include(\"blue.endless:jankson:${project.jankson_version}\"))\n}\n</code></pre> <p>And add <code>jankson_version=1.2.3</code> to your <code>gradle.properties</code>  file. (or any other version you may want to use)</p>"},{"location":"api/config/","title":"Configuration","text":"<p>BlossomBridge provides a simple, albeit plain, way to add Config to your mod using JSON5 files loaded using Jankson.</p> <p>Start by making a new class and implementing <code>ConfigClass</code>: ConfigClassExample.java<pre><code>public class ConfigClassExample implements ConfigClass {\n\n}\n</code></pre></p> <p>Due to the implementation, you are forced to make a <code>validate()</code> method. This method is run every time your Config is read and deserialized to ensure your Config isn't invalid according to your validation. We will look into using this later. </p> ConfigClassExample.java<pre><code>@Override\npublic void validate() {\n\n}\n</code></pre> <p>Adding data is possible as follows: ConfigClassExample.java<pre><code>public class ConfigClassExample implements ConfigClass {\n    public boolean foo = false; // (1)!\n\n    public UtilConfig util_config = new UtilConfig() // (2)!\n\n    public static class UtilConfig {\n        public boolean debug_mode = false // (3)!\n\n        public boolean suppress_warns = false\n    }\n\n    @Override\n    public void validate() {\n\n    }\n}\n</code></pre></p> <ol> <li>The field name is the key in the json5 file, you can set a default value by initialising the field.</li> <li>Nested configs are possible by using static inner classes, look at the next annotation for more info.</li> <li> <p>By making a static inner class, and putting fields in it, you essentially create a nested config. (1)</p> <ol> <li>A nested config is a config option that is part of another config (kind of like this annotation ), you reference them like <code>util_config.debug_mode</code> and <code>util_config.suppress_warns</code>.</li> </ol> </li> </ol> Jankson Comments  <p>If you chose to add and include Jankson, you can use comments as follows: ConfigClassExample.java<pre><code>@Comment(\"Very cool comment!\")\npublic boolean foo = false;\n@Comment(\"\"\"\n        Lorem ipsum is just a silly placeholder text that can definetly show the following:\n        Having to use multi-line comments!\"\"\")\npublic boolean bar = true;\n</code></pre> It will look like this: <pre><code>// Very cool comment!\n\"foo\": false,\n/*\n    Lorem ipsum is just a silly placeholder text that can definitely show the following:\n    Having to use multi-line comments!\n*/\n\"bar\": true\n</code></pre></p> <p>How nice, in the next doc we will look into using <code>validate()</code> to validate your values!</p>","tags":["Developer Guides","Configuration Module"]},{"location":"api/config_managers/","title":"Config Files","text":"<p>Ok that's very cool and stuff, but how do we actually turn this into json5 files and use it in our code?</p> <p>As mentioned a few times before, BlossomBridge utilises a library called Jankson to parse, read, (de)serialise and write json5 files.</p> <p>An implementation of using Jankson with our <code>ConfigClass</code> is a <code>ConfigManager</code>!</p> <p>A <code>ConfigManager</code> can be created to do various things with your Config instance, such as saving or loading it, but also getting Strings that hold the plain json5 code.</p> <p>In order to create a new <code>ConfigManager</code> we need a few things:</p> <ol> <li>A <code>File</code> where we store our json5 code.</li> <li>A <code>ConfigClass</code> where we get our data from.</li> </ol> <p>Create a new <code>ConfigManager</code> in your <code>ModInitializer</code> class, let's use our <code>ValidateExample</code> class as the <code>ConfigClass</code>: ExampleMod.java<pre><code>public class ExampleMod implements ModInitializer {\n    private static final File CONFIG_DIR = FabricLoader.getInstance().getConfigDir().toFile();\n    private static final File FILE = new File(CONFIG_DIR, \"validate-example.json5\");\n    public static final ConfigManager&lt;ValidateExample&gt; CONFIG_MANAGER =\n            new ConfigManager&lt;&gt;(ValidateExample.class, FILE);\n\n    @Override\n    public void onInitialize() {\n\n    }\n}\n</code></pre></p> Note <p><code>ConfigManager</code> has a Type Parameter of <code>T extends ConfigClass?</code>, meaning you need to put a class that implements <code>ConfigClass</code> in between the <code>&lt;&gt;</code>.</p> <p>Currently, though, this still does nothing. Because in order to actually make Jankson start reading from and writing to the Config file, you need to load it as follows: ExampleMod.java<pre><code>    ...\n    public static final ConfigManager&lt;ValidateExample&gt; CONFIG_MANAGER =\n            new ConfigManager&lt;&gt;(ValidateExample.class, FILE);\n\n    @Override\n    public void onInitialize() {\n        CONFIG_MANAGER.loadConfig();\n    }\n}\n</code></pre></p> <p>Note</p> <p>If it's your first time loading the Config file, it will create a new file with the default values and then put the values into a config instance. If the mod has been loaded multiple times before, it will apply your validation code from the last doc and then turn it into a config instance.</p> <p>You can access the current Config Instance by running <code>CONFIG_MANAGER.getConfig()</code></p> <p>Example Usage: ExampleMod.java<pre><code>    ...\n    public static final ConfigManager&lt;ValidateExample&gt; CONFIG_MANAGER =\n        new ConfigManager&lt;&gt;(ValidateExample.class, FILE);\n\n    @Override\n    public void onInitialize() {\n        CONFIG_MANAGER.loadConfig();\n\n        ValidateExample config = CONFIG_MANAGER.getConfig();\n        System.out.println(\"Amount of orbs set: \" + config.orbs);\n    }\n}\n</code></pre></p> <p>Note</p> <p>You can find your config file at <code>run/config/&lt;name&gt;.json5</code> unless you set a different <code>File</code> for the <code>ConfigManager</code>.</p> <p>And that's it! It might be finicky at first, but messing around with it as much as you can is definitely suggested and especially fun if it works!</p> <p>In the next docs we can look at how you can set up Logging with your Config.</p>","tags":["Developer Guides","Configuration Module"]},{"location":"api/config_validation/","title":"Ranges, Sets and Validation","text":"<p>Picture this! You want your users to be able to add a certain amount of orbs to their world, but no more than 60, but uhhh, there needs to be at least one!</p> <p>In order to achieve this we can \"define\" ranges for your config values using the <code>validate()</code> method!</p> <p>Start by making some value(s) in your config class, in our case we will use <code>orbs</code>: ValidateExample.java<pre><code>public class ValidateExample implements ConfigClass {\n    public int orbs = 1;\n\n    @Override\n    public void validate() {\n\n    }\n}\n</code></pre></p> <p>We can enforce a range by checking the value of <code>orbs</code> in the <code>validate()</code> method: ValidateExample.java<pre><code>public class ValidateExample implements ConfigClass {\n    public int orbs = 1;\n\n    @Override\n    public void validate() {\n        // Is orbs lower than 1 or higher than 60?\n        if (orbs &lt; 1 || orbs &gt; 60) {\n            // Reset it to 1\n            orbs = 1;\n        }\n    }\n}\n</code></pre></p> <p>We check if the value orbs is lower than 1 or higher than 60, if it is, we reset the value back to <code>1</code>!  </p> <p>Tip</p> <p>If you can use Comments, try to make your users aware of this range by stating it in a Comment!</p> <p>We can do the same logic for all sorts of Types, such as Strings: ValidateExample.java<pre><code>public class ValidateExample implements ConfigClass {\n    public int orbs = 1;\n    public String orb_colour = \"RED\"\n\n    @Override\n    public void validate() {\n        // Is orbs lower than 1 or higher than 60?\n        if (orbs &lt; 1 || orbs &gt; 60) {\n            // Reset it to 1\n            orbs = 1;\n        }\n\n        // (1)!\n        List&lt;String&gt; colours = List.of(\"RED\", \"BLUE\", \"YELLOW\", \"GREEN\");\n        // Is orb_colour's value not in the list?\n        if (!colours.contains(orb_colour)) {\n            // Reset it to \"RED\"\n            orb_colour = \"RED\";\n        }\n    }\n}\n</code></pre></p> <ol> <li>You could also make an enum class and use <code>.values()</code>!</li> </ol> <p>Throwing RuntimeExceptions</p> <p>Not feeling like automatically correcting your user's mistakes and just make their runtime throw an exception? BlossomBridge provides two <code>RuntimeException</code>s you can throw in case something went wrong when loading your Config.</p> <code>InvalidConfigFileException</code><code>InvalidConfigFormatException</code> <p>Seems self-explanatory, if the file is invalid, throw this exception and call it a day.</p> <p>For those who regularly change their Config data, setting so-called \"Config Versions\" may be a smart idea. If you wish to throw an exception when a Config Version set inside a config file is invalid/outdated, you can throw this exception!</p> <p>In the next doc we'll be looking at how to actually use our files and data!</p>","tags":["Developer Guides","Configuration Module"]},{"location":"api/logging/","title":"Creating a LoggingHandler","text":"<p>Warning</p> <p>This document assumes you have read and understood the part \"Configuration\". If you haven't already, read it first and then come back.</p> <p>To maintain a consistent log format for all our mods, we decided to make a central class that handles all logging for them.</p> <p>If you haven't already, make a <code>ConfigClass</code> and an accompanying <code>ConfigManager</code>,  please note that you are forced to extend <code>BasicConfigClass</code> as the Type Parameter of a <code>LoggingHandler</code>  will not accept a regular <code>ConfigClass</code> for the mere reason that it doesn't guarantee a <code>debug_mode</code> and <code>suppress_warns</code> value which are both needed for Logging.</p> <p>Example Classes: LoggingExample.java<pre><code>public class LoggingExample extends BasicConfigClass {\n\n}\n</code></pre></p> Warning <p>This class may look awfully empty as it misses a <code>validate()</code> method. This is because <code>BasicConfigClass</code> already has an implementation of it. If you do decide to override the <code>validate()</code> method, make sure to run <code>super.validate()</code> in order to have <code>BasicConfigClass</code> properly validate too.</p> ExampleMod.java<pre><code>public class ExampleMod implements ModInitializer {\n    private static final File CONFIG_DIR = FabricLoader.getInstance().getConfigDir().toFile();\n    private static final File FILE = new File(CONFIG_DIR, \"logging-example.json5\");\n    public static final ConfigManager&lt;LoggingExample&gt; CONFIG_MANAGER =\n        new ConfigManager&lt;&gt;(LoggingExample.class, FILE);\n\n    @Override\n    public void onInitialize() {\n        CONFIG_MANAGER.loadConfig();\n    }\n}\n</code></pre> <p>We can now construct a new <code>LoggingHandler</code> in either of the following two ways:</p> Manually inputting <code>Logger</code>sAutomatically generating <code>Logger</code>s (Recommended) ExampleMod.java<pre><code>    ...\n    public static final ConfigManager&lt;LoggingExample&gt; CONFIG_MANAGER =\n            new ConfigManager&lt;&gt;(LoggingExample.class, FILE);\n    public static final LoggingHandler&lt;LoggingExample&gt; LOGGING =\n            new LoggingHandler&lt;&gt;(\n                    LoggerFactory.getLogger(\"ExampleMod|Main\"),\n                    LoggerFactory.getLogger(\"ExampleMod|Debug\"),\n                    CONFIG_MANAGER\n            )\n    ...\n</code></pre> ExampleMod.java<pre><code>    ...\n    public static final ConfigManager&lt;LoggingExample&gt; CONFIG_MANAGER =\n            new ConfigManager&lt;&gt;(LoggingExample.class, FILE);\n    public static final LoggingHandler&lt;LoggingExample&gt; LOGGING =\n            new LoggingHandler&lt;&gt;(\"ExampleMod\", CONFIG_MANAGER)\n            // This will make two Loggers: \"ExampleMod|Main\" and \"ExampleMod|Debug\"\n    ...\n</code></pre> <p>In the next doc we'll see how to use this <code>LoggingHandler</code>.</p>","tags":["Developer Guides","Configuration Module","Logging Module"]},{"location":"api/logging_usage/","title":"Using a LoggingHandler","text":"<p>All usages</p> <p>A <code>LoggingHandler</code> has a lot of options to log messages with, to view them all, you're better off looking at the comments in the following code block: Note that it is written in Kotlin !</p> LoggingHandler.kt LoggingHandler.kt<pre><code>package org.tywrapstudios.blossombridge.api.logging\n\nimport org.slf4j.Logger\nimport org.slf4j.LoggerFactory\nimport org.tywrapstudios.blossombridge.api.config.BasicConfigClass\nimport org.tywrapstudios.blossombridge.api.config.ConfigManager\n\n/**\n * A general-purpose Logging Handler compatible with the modular configuration system.\n * This class dynamically fetches configuration values for logging behavior.\n *\n * Note that this should only be used when a Main Config Object (which have to extend [BasicConfigClass] anyway) object is available.\n */\nclass LoggingHandler&lt;T : BasicConfigClass&gt; {\n    private val main: Logger\n    private val debug: Logger\n    private val manager: ConfigManager&lt;T&gt;\n\n    /**\n     * Construct a new [LoggingHandler].\n     * @param mainLogger A [Logger] that logs the main parts of the mod.\n     * @param debugLogger A [Logger] that logs the debug parts of the mod.\n     * @param configManager Your [ConfigManager], this is needed to get various values from your Config.\n     */\n    constructor(mainLogger: Logger, debugLogger: Logger, configManager: ConfigManager&lt;T&gt;) {\n        this.main = mainLogger\n        this.debug = debugLogger\n        this.manager = configManager\n    }\n\n    /**\n     * Construct a new [LoggingHandler].\n     * @param name A [String] that represents your mod's name, [Logger]`s` will automatically be made for you.\n     * @param configManager Your [ConfigManager], this is needed to get various values from your Config.\n     */\n    constructor(name: String, configManager: ConfigManager&lt;T&gt;) {\n        this.main = LoggerFactory.getLogger(\"$name|Main\")\n        this.debug = LoggerFactory.getLogger(\"$name|Debug\")\n        this.manager = configManager\n    }\n\n    /**\n     * Log a String to the info level of the main logger.\n     *\n     * @param message The Message String to log.\n     */\n    fun info(message: String) {\n        main.info(message)\n    }\n\n    /**\n     * Log a String to the warn level of the main logger.\n     *\n     * @param message The Message String to log.\n     */\n    fun warn(message: String) {\n        if (!conf().util_config.suppress_warns) {\n            main.warn(message)\n        }\n    }\n\n    /**\n     * Log a String to the error level of the main logger.\n     *\n     * @param message The Message String to log.\n     */\n    fun error(message: String) {\n        if (!conf().util_config.suppress_warns) {\n            main.error(message)\n        }\n    }\n\n    /**\n     * Log a String to the info and debug level of the debug logger.\n     *\n     * @param message The Message String to log.\n     */\n    fun debug(message: String) {\n        if (conf().util_config.debug_mode) {\n            debug.info(message)\n        }\n        literalDebug(message)\n    }\n\n    /**\n     * Log a String to the debug level of the debug logger.\n     *\n     * @param message The Message String to log.\n     */\n    fun literalDebug(message: String) {\n        debug.debug(message)\n    }\n\n    /**\n     * Log a String to the warn level of the debug logger.\n     *\n     * @param message The Message String to log.\n     */\n    fun debugWarning(message: String) {\n        if (conf().util_config.debug_mode &amp;&amp; !conf().util_config.suppress_warns) {\n            debug.warn(message)\n        }\n    }\n\n    private fun conf(): T {\n        return manager.getConfig()!!\n    }\n}\n</code></pre> <p>Apart from this, using a <code>LoggingHandler</code> is not hard at all. Just call the respective methods for the log levels and whatnot.</p> <p>A few notes though:</p> <p>Config</p> <p>The entire reason you need to extend <code>BasicConfigClass</code> is so there are debug and warn suppression options available that match up with calling methods in the class.</p> <p>Debug</p> <p><code>LoggingHandler.debug(message: String)</code> will call your message on the INFO level of the debug <code>Logger</code>, this counts for some other debug methods too.</p> <p>Literal Debug</p> <p>While <code>.debug(message: String)</code> sends to the INFO level of the debug <code>Logger</code>, <code>.literalDebug(message: String)</code> sends to its DEBUG level. It also fully ignores config settings, meaning it can be safely run before mod initialisation without having to worry about your config not having read yet.</p>","tags":["Developer Guides","Logging Module"]},{"location":"developers/","title":"Getting Started","text":"<p>Hello fellow developer, welcome to BlossomBridge!</p>","tags":["Developer Guides"]},{"location":"developers/#importing-into-your-ide","title":"Importing into your IDE<sup>1</sup>","text":"<p>You can get the BlossomBridge sources from the JitPack  maven repository.</p> Groovy build.gradle<pre><code>repositories {\n    maven { url = 'https://jitpack.io' }\n}   \n\ndependencies {\n    ...\n\n    // BlossomBridge\n    modImplementation \"com.github.Tywrap-Studios:BlossomBridge:${project.blossombridge_version}\"\n}\n</code></pre> Using Local files <p>Firstly, obtain a <code>blossombridge-&lt;version&gt;-sources.jar</code> from any of the following sources:</p> PlatformBuildingGitHub Actions <p>Currently, BlossomBridge is only available on Modrinth. You can get the jars here.</p> <p>You can do this by cloning the repository and running <code>./gradlew build</code> in the root directory of the project. Your sources jar will be in a folder called <code>build/libs</code>.</p> <ol> <li>On the main page of the Repository, click \"Actions\"  in the navigation bar on top.</li> <li>On the left hand side, there is a list of Workflows , click the one named <code>build</code>.</li> <li>Click into the top NON-FAILED action.<ol> <li>You may filter by branch  or release tag  using the filters  on the right side, or target a specific build in the list. This may be handy if you don't want to end up with an in-dev, unstable or broken version.</li> </ol> </li> <li>Scroll down until you see a text named \"Artifacts\", after you click this a zip file containing the main jar and the sources jar will be downloaded onto your machine. Extract these jars and use the one that is affixed with <code>-sources.jar</code>.</li> </ol> <p>After obtaining said file, it is best to make a new directory in your project called <code>libs/</code>, and put the jar inside of it.</p> <p>Now you can manually add it to your repositories and dependencies:</p> Groovy build.gradle<pre><code>dependencies {\n    ...\n\n    // blossombridge\n    modImplementation files(\"libs/blossombridge-${project.blossombridge_version}-sources.jar\")\n}\n</code></pre>","tags":["Developer Guides"]},{"location":"developers/#finalizing","title":"Finalizing","text":"<p>Finally, add the following to your <code>gradle.properties</code> file: <pre><code>blossombridge_version=x.y.z\n</code></pre> and this to your <code>fabric.mod.json</code>: <pre><code>{\n  \"depends\": {\n    \"blossombridge\": \"&gt;=x.y.z\"\n  }\n}\n</code></pre> And replace <code>x.y.z</code> with your major, minor and patch version, e.g. 2.0.0.</p> When using JitPack <p>JitPack might not have made an Artifact yet, if your imports are failing, go over to the JitPack page of the repository and check if a build might have failed.</p> Local versioning <p>If you are using a local jar, check if the version in the file name corresponds with the version you're trying to use.</p> <ol> <li> <p> Integrated Development Environment, like IntelliJ IDEA or Eclipse.\u00a0\u21a9</p> </li> </ol>","tags":["Developer Guides"]},{"location":"developers/updating/","title":"2.0.0 -&gt; 2.0.1","text":"<p>2.0.1 focused mainly on fixing minor flaws the 2.0.0 update had, updating is suggested, but take note of the problems 2.0.0 serves.</p>","tags":["Developer Guides"]},{"location":"developers/updating/#patches","title":"Patches:","text":"<ol> <li>Wrongly formatted MC version dependency in <code>fabric.mod.json</code>.</li> <li><code>ConfigManager.getConfig()</code> is not null safe, while it used to be before the Kotlin rewrite.    (oh the irony)</li> </ol>","tags":["Developer Guides"]},{"location":"developers/updating/#updating","title":"Updating","text":"<p>This patch is mostly internal, so no codebase changes are technically needed. Do note that you can remove any null checks for your config if you have implemented them.</p>","tags":["Developer Guides"]}]}